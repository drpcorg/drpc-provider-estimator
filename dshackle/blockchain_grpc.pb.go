// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: blockchain.proto

package dshackle

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BlockchainClient is the client API for Blockchain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockchainClient interface {
	SubscribeHead(ctx context.Context, in *Chain, opts ...grpc.CallOption) (Blockchain_SubscribeHeadClient, error)
	SubscribeBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (Blockchain_SubscribeBalanceClient, error)
	SubscribeTxStatus(ctx context.Context, in *TxStatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeTxStatusClient, error)
	GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (Blockchain_GetBalanceClient, error)
	// *
	// Fee Estimation service. The server tries to estimate a fair fee based on the last N blocks.
	EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)
	NativeCall(ctx context.Context, in *NativeCallRequest, opts ...grpc.CallOption) (Blockchain_NativeCallClient, error)
	NativeSubscribe(ctx context.Context, in *NativeSubscribeRequest, opts ...grpc.CallOption) (Blockchain_NativeSubscribeClient, error)
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	SubscribeStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeStatusClient, error)
	SubscribeNodeStatus(ctx context.Context, in *SubscribeNodeStatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeNodeStatusClient, error)
}

type blockchainClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockchainClient(cc grpc.ClientConnInterface) BlockchainClient {
	return &blockchainClient{cc}
}

func (c *blockchainClient) SubscribeHead(ctx context.Context, in *Chain, opts ...grpc.CallOption) (Blockchain_SubscribeHeadClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[0], "/emerald.Blockchain/SubscribeHead", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainSubscribeHeadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_SubscribeHeadClient interface {
	Recv() (*ChainHead, error)
	grpc.ClientStream
}

type blockchainSubscribeHeadClient struct {
	grpc.ClientStream
}

func (x *blockchainSubscribeHeadClient) Recv() (*ChainHead, error) {
	m := new(ChainHead)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) SubscribeBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (Blockchain_SubscribeBalanceClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[1], "/emerald.Blockchain/SubscribeBalance", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainSubscribeBalanceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_SubscribeBalanceClient interface {
	Recv() (*AddressBalance, error)
	grpc.ClientStream
}

type blockchainSubscribeBalanceClient struct {
	grpc.ClientStream
}

func (x *blockchainSubscribeBalanceClient) Recv() (*AddressBalance, error) {
	m := new(AddressBalance)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) SubscribeTxStatus(ctx context.Context, in *TxStatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeTxStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[2], "/emerald.Blockchain/SubscribeTxStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainSubscribeTxStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_SubscribeTxStatusClient interface {
	Recv() (*TxStatus, error)
	grpc.ClientStream
}

type blockchainSubscribeTxStatusClient struct {
	grpc.ClientStream
}

func (x *blockchainSubscribeTxStatusClient) Recv() (*TxStatus, error) {
	m := new(TxStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (Blockchain_GetBalanceClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[3], "/emerald.Blockchain/GetBalance", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainGetBalanceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_GetBalanceClient interface {
	Recv() (*AddressBalance, error)
	grpc.ClientStream
}

type blockchainGetBalanceClient struct {
	grpc.ClientStream
}

func (x *blockchainGetBalanceClient) Recv() (*AddressBalance, error) {
	m := new(AddressBalance)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {
	out := new(EstimateFeeResponse)
	err := c.cc.Invoke(ctx, "/emerald.Blockchain/EstimateFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainClient) NativeCall(ctx context.Context, in *NativeCallRequest, opts ...grpc.CallOption) (Blockchain_NativeCallClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[4], "/emerald.Blockchain/NativeCall", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainNativeCallClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_NativeCallClient interface {
	Recv() (*NativeCallReplyItem, error)
	grpc.ClientStream
}

type blockchainNativeCallClient struct {
	grpc.ClientStream
}

func (x *blockchainNativeCallClient) Recv() (*NativeCallReplyItem, error) {
	m := new(NativeCallReplyItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) NativeSubscribe(ctx context.Context, in *NativeSubscribeRequest, opts ...grpc.CallOption) (Blockchain_NativeSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[5], "/emerald.Blockchain/NativeSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainNativeSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_NativeSubscribeClient interface {
	Recv() (*NativeSubscribeReplyItem, error)
	grpc.ClientStream
}

type blockchainNativeSubscribeClient struct {
	grpc.ClientStream
}

func (x *blockchainNativeSubscribeClient) Recv() (*NativeSubscribeReplyItem, error) {
	m := new(NativeSubscribeReplyItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, "/emerald.Blockchain/Describe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainClient) SubscribeStatus(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[6], "/emerald.Blockchain/SubscribeStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainSubscribeStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_SubscribeStatusClient interface {
	Recv() (*ChainStatus, error)
	grpc.ClientStream
}

type blockchainSubscribeStatusClient struct {
	grpc.ClientStream
}

func (x *blockchainSubscribeStatusClient) Recv() (*ChainStatus, error) {
	m := new(ChainStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainClient) SubscribeNodeStatus(ctx context.Context, in *SubscribeNodeStatusRequest, opts ...grpc.CallOption) (Blockchain_SubscribeNodeStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &Blockchain_ServiceDesc.Streams[7], "/emerald.Blockchain/SubscribeNodeStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainSubscribeNodeStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Blockchain_SubscribeNodeStatusClient interface {
	Recv() (*NodeStatusResponse, error)
	grpc.ClientStream
}

type blockchainSubscribeNodeStatusClient struct {
	grpc.ClientStream
}

func (x *blockchainSubscribeNodeStatusClient) Recv() (*NodeStatusResponse, error) {
	m := new(NodeStatusResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BlockchainServer is the server API for Blockchain service.
// All implementations must embed UnimplementedBlockchainServer
// for forward compatibility
type BlockchainServer interface {
	SubscribeHead(*Chain, Blockchain_SubscribeHeadServer) error
	SubscribeBalance(*BalanceRequest, Blockchain_SubscribeBalanceServer) error
	SubscribeTxStatus(*TxStatusRequest, Blockchain_SubscribeTxStatusServer) error
	GetBalance(*BalanceRequest, Blockchain_GetBalanceServer) error
	// *
	// Fee Estimation service. The server tries to estimate a fair fee based on the last N blocks.
	EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)
	NativeCall(*NativeCallRequest, Blockchain_NativeCallServer) error
	NativeSubscribe(*NativeSubscribeRequest, Blockchain_NativeSubscribeServer) error
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	SubscribeStatus(*StatusRequest, Blockchain_SubscribeStatusServer) error
	SubscribeNodeStatus(*SubscribeNodeStatusRequest, Blockchain_SubscribeNodeStatusServer) error
	mustEmbedUnimplementedBlockchainServer()
}

// UnimplementedBlockchainServer must be embedded to have forward compatible implementations.
type UnimplementedBlockchainServer struct {
}

func (UnimplementedBlockchainServer) SubscribeHead(*Chain, Blockchain_SubscribeHeadServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeHead not implemented")
}
func (UnimplementedBlockchainServer) SubscribeBalance(*BalanceRequest, Blockchain_SubscribeBalanceServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeBalance not implemented")
}
func (UnimplementedBlockchainServer) SubscribeTxStatus(*TxStatusRequest, Blockchain_SubscribeTxStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTxStatus not implemented")
}
func (UnimplementedBlockchainServer) GetBalance(*BalanceRequest, Blockchain_GetBalanceServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedBlockchainServer) EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateFee not implemented")
}
func (UnimplementedBlockchainServer) NativeCall(*NativeCallRequest, Blockchain_NativeCallServer) error {
	return status.Errorf(codes.Unimplemented, "method NativeCall not implemented")
}
func (UnimplementedBlockchainServer) NativeSubscribe(*NativeSubscribeRequest, Blockchain_NativeSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method NativeSubscribe not implemented")
}
func (UnimplementedBlockchainServer) Describe(context.Context, *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (UnimplementedBlockchainServer) SubscribeStatus(*StatusRequest, Blockchain_SubscribeStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeStatus not implemented")
}
func (UnimplementedBlockchainServer) SubscribeNodeStatus(*SubscribeNodeStatusRequest, Blockchain_SubscribeNodeStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeNodeStatus not implemented")
}
func (UnimplementedBlockchainServer) mustEmbedUnimplementedBlockchainServer() {}

// UnsafeBlockchainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockchainServer will
// result in compilation errors.
type UnsafeBlockchainServer interface {
	mustEmbedUnimplementedBlockchainServer()
}

func RegisterBlockchainServer(s grpc.ServiceRegistrar, srv BlockchainServer) {
	s.RegisterService(&Blockchain_ServiceDesc, srv)
}

func _Blockchain_SubscribeHead_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Chain)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).SubscribeHead(m, &blockchainSubscribeHeadServer{stream})
}

type Blockchain_SubscribeHeadServer interface {
	Send(*ChainHead) error
	grpc.ServerStream
}

type blockchainSubscribeHeadServer struct {
	grpc.ServerStream
}

func (x *blockchainSubscribeHeadServer) Send(m *ChainHead) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_SubscribeBalance_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BalanceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).SubscribeBalance(m, &blockchainSubscribeBalanceServer{stream})
}

type Blockchain_SubscribeBalanceServer interface {
	Send(*AddressBalance) error
	grpc.ServerStream
}

type blockchainSubscribeBalanceServer struct {
	grpc.ServerStream
}

func (x *blockchainSubscribeBalanceServer) Send(m *AddressBalance) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_SubscribeTxStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TxStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).SubscribeTxStatus(m, &blockchainSubscribeTxStatusServer{stream})
}

type Blockchain_SubscribeTxStatusServer interface {
	Send(*TxStatus) error
	grpc.ServerStream
}

type blockchainSubscribeTxStatusServer struct {
	grpc.ServerStream
}

func (x *blockchainSubscribeTxStatusServer) Send(m *TxStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_GetBalance_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BalanceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).GetBalance(m, &blockchainGetBalanceServer{stream})
}

type Blockchain_GetBalanceServer interface {
	Send(*AddressBalance) error
	grpc.ServerStream
}

type blockchainGetBalanceServer struct {
	grpc.ServerStream
}

func (x *blockchainGetBalanceServer) Send(m *AddressBalance) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServer).EstimateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emerald.Blockchain/EstimateFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServer).EstimateFee(ctx, req.(*EstimateFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blockchain_NativeCall_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NativeCallRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).NativeCall(m, &blockchainNativeCallServer{stream})
}

type Blockchain_NativeCallServer interface {
	Send(*NativeCallReplyItem) error
	grpc.ServerStream
}

type blockchainNativeCallServer struct {
	grpc.ServerStream
}

func (x *blockchainNativeCallServer) Send(m *NativeCallReplyItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_NativeSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NativeSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).NativeSubscribe(m, &blockchainNativeSubscribeServer{stream})
}

type Blockchain_NativeSubscribeServer interface {
	Send(*NativeSubscribeReplyItem) error
	grpc.ServerStream
}

type blockchainNativeSubscribeServer struct {
	grpc.ServerStream
}

func (x *blockchainNativeSubscribeServer) Send(m *NativeSubscribeReplyItem) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/emerald.Blockchain/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Blockchain_SubscribeStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).SubscribeStatus(m, &blockchainSubscribeStatusServer{stream})
}

type Blockchain_SubscribeStatusServer interface {
	Send(*ChainStatus) error
	grpc.ServerStream
}

type blockchainSubscribeStatusServer struct {
	grpc.ServerStream
}

func (x *blockchainSubscribeStatusServer) Send(m *ChainStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Blockchain_SubscribeNodeStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeNodeStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServer).SubscribeNodeStatus(m, &blockchainSubscribeNodeStatusServer{stream})
}

type Blockchain_SubscribeNodeStatusServer interface {
	Send(*NodeStatusResponse) error
	grpc.ServerStream
}

type blockchainSubscribeNodeStatusServer struct {
	grpc.ServerStream
}

func (x *blockchainSubscribeNodeStatusServer) Send(m *NodeStatusResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Blockchain_ServiceDesc is the grpc.ServiceDesc for Blockchain service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Blockchain_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emerald.Blockchain",
	HandlerType: (*BlockchainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EstimateFee",
			Handler:    _Blockchain_EstimateFee_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _Blockchain_Describe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeHead",
			Handler:       _Blockchain_SubscribeHead_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeBalance",
			Handler:       _Blockchain_SubscribeBalance_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTxStatus",
			Handler:       _Blockchain_SubscribeTxStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetBalance",
			Handler:       _Blockchain_GetBalance_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NativeCall",
			Handler:       _Blockchain_NativeCall_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NativeSubscribe",
			Handler:       _Blockchain_NativeSubscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeStatus",
			Handler:       _Blockchain_SubscribeStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeNodeStatus",
			Handler:       _Blockchain_SubscribeNodeStatus_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "blockchain.proto",
}
